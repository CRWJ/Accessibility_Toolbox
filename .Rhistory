ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Inverse Power Function")
neg_exp_f = function(t_ij,b0){exp(-b0*t_ij)}
NEG_EXP <- list(EXP0_12 = function(t_ij){neg_exp_f(t_ij, b0 = 0.12)},
EXP0_15 = function(t_ij){neg_exp_f(t_ij, b0 = 0.15)},
EXP0_22 = function(t_ij){neg_exp_f(t_ij, b0 = 0.22)},
EXP0_45 = function(t_ij){neg_exp_f(t_ij, b0 = 0.45)},
EXP_CUS = function(t_ij){neg_exp_f(t_ij, b0 = 0.10)}, # custom - set your own parameter
HN1997 = function(t_ij){neg_exp_f(t_ij, b0 = 0.1813)}) # from Handy and Niemeier (1997)
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=NEG_EXP$EXP0_12, aes(colour="EXP0_12"), size=1) +
stat_function(fun=NEG_EXP$EXP0_15, aes(colour="EXP0_15"), size=1) +
stat_function(fun=NEG_EXP$EXP0_22, aes(colour="EXP0_22"), size=1) +
stat_function(fun=NEG_EXP$EXP0_45, aes(colour="EXP0_45"), size=1) +
stat_function(fun=NEG_EXP$EXP_CUS, aes(colour="EXP_CUS"), size=1, linetype="dashed") +
stat_function(fun=NEG_EXP$HN1997, aes(colour="HN1997"), size=1, linetype="longdash") +
scale_color_discrete(limits = names(NEG_EXP)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Negative Exponential Function")
mgaus_f = function(t_ij,b0){exp(-t_ij^2/b0)}
MGAUS <- list(MGAUS10 = function(t_ij){mgaus_f(t_ij, b0 = 10)},
MGAUS40 = function(t_ij){mgaus_f(t_ij, b0 = 40)},
MGAUS100 = function(t_ij){mgaus_f(t_ij, b0 = 100)},
MGAUS180 = function(t_ij){mgaus_f(t_ij, b0 = 180)},
MGAUSCUS = function(t_ij){mgaus_f(t_ij, b0 = 360)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=MGAUS$MGAUS10, aes(colour="MGAUS10"), size=1) +
stat_function(fun=MGAUS$MGAUS40, aes(colour="MGAUS40"), size=1) +
stat_function(fun=MGAUS$MGAUS100, aes(colour="MGAUS100"), size=1) +
stat_function(fun=MGAUS$MGAUS180, aes(colour="MGAUS180"), size=1) +
stat_function(fun=MGAUS$MGAUSCUS, aes(colour="MGAUSCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(MGAUS)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Modified Gaussian Function")
cumr_f = function(t_ij,t_bar){ifelse(test = t_ij <= t_bar, yes = 1, no = 0)}
CUMR <- list(CUMR10 = function(t_ij){cumr_f(t_ij, t_bar = 10)},
CUMR20 = function(t_ij){cumr_f(t_ij, t_bar = 20)},
CUMR30 = function(t_ij){cumr_f(t_ij, t_bar = 30)},
CUMR40 = function(t_ij){cumr_f(t_ij, t_bar = 40)},
CUMRCUS = function(t_ij){cumr_f(t_ij, t_bar = 45)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=CUMR$CUMR10, aes(colour="CUMR10"), size=1) +
stat_function(fun=CUMR$CUMR20, aes(colour="CUMR20"), size=1) +
stat_function(fun=CUMR$CUMR30, aes(colour="CUMR30"), size=1) +
stat_function(fun=CUMR$CUMR40, aes(colour="CUMR40"), size=1) +
stat_function(fun=CUMR$CUMRCUS, aes(colour="CUMRCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(CUMR)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Cumulative Rectangular Function")
cuml_f = function(t_ij,t_bar){ifelse(test = t_ij <= t_bar, yes = (1-t_ij/t_bar), no = 0)}
CUML <- list(CUML10 = function(t_ij){cuml_f(t_ij, t_bar = 10)},
CUML20 = function(t_ij){cuml_f(t_ij, t_bar = 20)},
CUML30 = function(t_ij){cuml_f(t_ij, t_bar = 30)},
CUML40 = function(t_ij){cuml_f(t_ij, t_bar = 40)},
CUMLCUS = function(t_ij){cuml_f(t_ij, t_bar = 45)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=CUML$CUML10, aes(colour="CUML10"), size=1) +
stat_function(fun=CUML$CUML20, aes(colour="CUML20"), size=1) +
stat_function(fun=CUML$CUML30, aes(colour="CUML30"), size=1) +
stat_function(fun=CUML$CUML40, aes(colour="CUML40"), size=1) +
stat_function(fun=CUML$CUMLCUS, aes(colour="CUMLCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(CUML)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Cumulative Linear Function")
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=POW$POW2_0, aes(colour="POW2_0"), size=1) +
stat_function(fun=NEG_EXP$EXP0_15, aes(colour="EXP0_15"), size=1, linetype="dashed") +
stat_function(fun=MGAUS$MGAUS180, aes(colour="MGAUS180"), size=1, linetype="dotdash") +
stat_function(fun=CUML$CUML40, aes(colour="CUML40"), size=1, linetype="twodash") +
stat_function(fun=CUMR$CUMR40, aes(colour="CUMR40"), size=1, linetype="longdash") +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Figure 1. Impedance Function Comparison")
table1 <- read.csv("./data/table1.csv")
kable(table1, caption = "Table 1. Impedance Measures in the Accessibility Toolbox", col.names = c("Impedance<br/>Measure", "Impedance<br/>Parameter ", "<br/>Source"), escape = FALSE, format = "pandoc")
# you can run the code below to download the data (remember your api keys!)
# or load it pre-processed from here:
load(file = path(data_path, "nyc_cb_poly.RData"))
# Download OpenStreetMap data for the NYC metro area from Interline map extracts
download.file(url = paste0("https://app.interline.io/osm_extracts/download_latest?string_id=new-york_new-york&data_format=pbf&api_token=", interline_token),
destfile = file.path(r5_path, "osm.pbf"), mode = "wb")
nyc_subway_gtfs <- read_gtfs(path = file.path(r5_path, "nyct_subway.zip"))
summary(nyc_subway_gtfs)
# 1. Generalize calls to input simple features
# origins
origins_i <-  nyc_cb_poly
origins_id_field <- "Block_GEOID"
# destinations
destinations_j <-  nyc_cb_poly
destinations_id_field <- "Block_GEOID"
opportunities_j_field <- "total_emp"
# select your impedance functions
selected_f <- c("POW2_0", "EXP0_15", "MGAUS180", "CUML40", "CUMR40") # pick one or more impedance functions
# 2. R5 Travel Time Matrix Options. See https://rdrr.io/cran/r5r/man/travel_time_matrix.html for more detail
# R5 allows for multiple combinations of transport modes. The options include:
## Transit modes
# TRAM, SUBWAY, RAIL, BUS, FERRY, CABLE_CAR, GONDOLA, FUNICULAR.
# The option 'TRANSIT' automatically considers all public transport modes available.
## Non transit modes
# WALK, BICYCLE, CAR, BICYCLE_RENT, CAR_PARK
# define your travel modes
mode <- c("WALK", "TRANSIT")
# egress mode
#mode_egress = "WALK" # Transport mode used after egress from public transport; it can be either 'WALK', 'BICYCLE', or 'CAR'. Defaults to "WALK"
# walk speed
#walk_speed = 3.6 #Average walk speed in km/h. Defaults to 3.6 km/h
# bike speed
#bike_speed = 12 # Average cycling speed in km/h. Defaults to 12 km/h
# max rides
#max_rides = 3 # The max number of public transport rides allowed in the same trip. Defaults to 3
# level of traffic stress (cycling)
#max_lts = 2 # The maximum level of traffic stress that cyclists will tolerate. A value of 1 means cyclists will only travel through the quietest streets, while a value of 4 indicates cyclists can travel through any road; defaults to 2
# define trip start datetime
departure_datetime <- as.POSIXct("2021-03-22 08:00:00",  # must be within calendar range of gtfs
format = "%Y-%m-%d %H:%M:%S",
tz = "America/New_York") # see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for list of time zone codes
# maximum walk distance (in metres)
max_walk_dist = 4000
# max trip duration (minutes)
max_trip_duration = 120
# processing batch size - how many origin rows to process at one time
chunksize = 500 # how many origins to consider at one time; set to nrow(origins_sf) if you don't want to use
# multithreading
n_threads = Inf # The number of threads to use in parallel computing; defaults to use all available threads (Inf)
r5r_core <- setup_r5(data_path = r5_path, verbose = FALSE)
# the r5r package requires Java Development Kit version 11, which can be downloaded from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html
# assign memory for r5r to work with
options(java.parameters = "-Xmx6G")
# load packages
library(corrplot)
library(httr)
library(knitr)
library(lehdr)
library(tidyverse)
library(fs)
library(r5r)
library(sf)
library(tidycensus)
library(tidytransit)
library(tmap)
library(viridis)
library(progress)
library(arrow)
# setup options
tmap_mode("plot")
# setup keys
census_api_key("cd604a56410fa739c5ecf7798624993254b93b60") # get from https://api.census.gov/data/key_signup.html
interline_token <- "f35e6a75-95a1-4ad3-adc2-7c09bfb10fbb" # for OSM extract from https://www.interline.io/osm/extracts/
# create data directories
data_path <- dir_create("./data") # for storing data
ttm_path <- dir_create("./r5_ttm") # for storing od matrix
r5_path <- dir_create("./r5_graph") # for the r5 network graph
# first define the travel time increment, in this case from 0 to 60 minutes
t_ij <- data.frame(t_ij = seq(from = 0, to = 60, by=1))
power_f <- function(t_ij,b0){ifelse(test = t_ij < 1, yes = 1, no = t_ij^-b0)}
POW <- list(POW0_8 = function(t_ij){power_f(t_ij, b0 = 0.8)},
POW1_0 = function(t_ij){power_f(t_ij, b0 = 1.0)},
POW1_5 = function(t_ij){power_f(t_ij, b0 = 1.5)},
POW2_0 = function(t_ij){power_f(t_ij, b0 = 2.0)},
POW_CUS = function(t_ij){power_f(t_ij, b0 = 0.5)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=POW$POW0_8, aes(colour="POW0_8"), size=1) +
stat_function(fun=POW$POW1_0, aes(colour="POW1_0"), size=1) +
stat_function(fun=POW$POW1_5, aes(colour="POW1_5"), size=1) +
stat_function(fun=POW$POW2_0, aes(colour="POW2_0"), size=1) +
stat_function(fun=POW$POW_CUS, aes(colour="POW_CUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(POW)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Inverse Power Function")
neg_exp_f = function(t_ij,b0){exp(-b0*t_ij)}
NEG_EXP <- list(EXP0_12 = function(t_ij){neg_exp_f(t_ij, b0 = 0.12)},
EXP0_15 = function(t_ij){neg_exp_f(t_ij, b0 = 0.15)},
EXP0_22 = function(t_ij){neg_exp_f(t_ij, b0 = 0.22)},
EXP0_45 = function(t_ij){neg_exp_f(t_ij, b0 = 0.45)},
EXP_CUS = function(t_ij){neg_exp_f(t_ij, b0 = 0.10)}, # custom - set your own parameter
HN1997 = function(t_ij){neg_exp_f(t_ij, b0 = 0.1813)}) # from Handy and Niemeier (1997)
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=NEG_EXP$EXP0_12, aes(colour="EXP0_12"), size=1) +
stat_function(fun=NEG_EXP$EXP0_15, aes(colour="EXP0_15"), size=1) +
stat_function(fun=NEG_EXP$EXP0_22, aes(colour="EXP0_22"), size=1) +
stat_function(fun=NEG_EXP$EXP0_45, aes(colour="EXP0_45"), size=1) +
stat_function(fun=NEG_EXP$EXP_CUS, aes(colour="EXP_CUS"), size=1, linetype="dashed") +
stat_function(fun=NEG_EXP$HN1997, aes(colour="HN1997"), size=1, linetype="longdash") +
scale_color_discrete(limits = names(NEG_EXP)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Negative Exponential Function")
mgaus_f = function(t_ij,b0){exp(-t_ij^2/b0)}
MGAUS <- list(MGAUS10 = function(t_ij){mgaus_f(t_ij, b0 = 10)},
MGAUS40 = function(t_ij){mgaus_f(t_ij, b0 = 40)},
MGAUS100 = function(t_ij){mgaus_f(t_ij, b0 = 100)},
MGAUS180 = function(t_ij){mgaus_f(t_ij, b0 = 180)},
MGAUSCUS = function(t_ij){mgaus_f(t_ij, b0 = 360)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=MGAUS$MGAUS10, aes(colour="MGAUS10"), size=1) +
stat_function(fun=MGAUS$MGAUS40, aes(colour="MGAUS40"), size=1) +
stat_function(fun=MGAUS$MGAUS100, aes(colour="MGAUS100"), size=1) +
stat_function(fun=MGAUS$MGAUS180, aes(colour="MGAUS180"), size=1) +
stat_function(fun=MGAUS$MGAUSCUS, aes(colour="MGAUSCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(MGAUS)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Modified Gaussian Function")
cumr_f = function(t_ij,t_bar){ifelse(test = t_ij <= t_bar, yes = 1, no = 0)}
CUMR <- list(CUMR10 = function(t_ij){cumr_f(t_ij, t_bar = 10)},
CUMR20 = function(t_ij){cumr_f(t_ij, t_bar = 20)},
CUMR30 = function(t_ij){cumr_f(t_ij, t_bar = 30)},
CUMR40 = function(t_ij){cumr_f(t_ij, t_bar = 40)},
CUMRCUS = function(t_ij){cumr_f(t_ij, t_bar = 45)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=CUMR$CUMR10, aes(colour="CUMR10"), size=1) +
stat_function(fun=CUMR$CUMR20, aes(colour="CUMR20"), size=1) +
stat_function(fun=CUMR$CUMR30, aes(colour="CUMR30"), size=1) +
stat_function(fun=CUMR$CUMR40, aes(colour="CUMR40"), size=1) +
stat_function(fun=CUMR$CUMRCUS, aes(colour="CUMRCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(CUMR)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Cumulative Rectangular Function")
cuml_f = function(t_ij,t_bar){ifelse(test = t_ij <= t_bar, yes = (1-t_ij/t_bar), no = 0)}
CUML <- list(CUML10 = function(t_ij){cuml_f(t_ij, t_bar = 10)},
CUML20 = function(t_ij){cuml_f(t_ij, t_bar = 20)},
CUML30 = function(t_ij){cuml_f(t_ij, t_bar = 30)},
CUML40 = function(t_ij){cuml_f(t_ij, t_bar = 40)},
CUMLCUS = function(t_ij){cuml_f(t_ij, t_bar = 45)}) # custom - set your own parameter
# plot different normalized functions
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=CUML$CUML10, aes(colour="CUML10"), size=1) +
stat_function(fun=CUML$CUML20, aes(colour="CUML20"), size=1) +
stat_function(fun=CUML$CUML30, aes(colour="CUML30"), size=1) +
stat_function(fun=CUML$CUML40, aes(colour="CUML40"), size=1) +
stat_function(fun=CUML$CUMLCUS, aes(colour="CUMLCUS"), size=1, linetype="dashed") +
scale_color_discrete(limits = names(CUML)) +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Cumulative Linear Function")
ggplot((t_ij), aes(t_ij)) +
stat_function(fun=POW$POW2_0, aes(colour="POW2_0"), size=1) +
stat_function(fun=NEG_EXP$EXP0_15, aes(colour="EXP0_15"), size=1, linetype="dashed") +
stat_function(fun=MGAUS$MGAUS180, aes(colour="MGAUS180"), size=1, linetype="dotdash") +
stat_function(fun=CUML$CUML40, aes(colour="CUML40"), size=1, linetype="twodash") +
stat_function(fun=CUMR$CUMR40, aes(colour="CUMR40"), size=1, linetype="longdash") +
xlab("travel time (minutes)") +
scale_x_continuous(breaks = seq(min(t_ij), max(t_ij), by = 10)) +
ylab("impedance weight") +
scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +
theme(legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.title = element_blank()) +
labs(title = "Figure 1. Impedance Function Comparison")
table1 <- read.csv("./data/table1.csv")
kable(table1, caption = "Table 1. Impedance Measures in the Accessibility Toolbox", col.names = c("Impedance<br/>Measure", "Impedance<br/>Parameter ", "<br/>Source"), escape = FALSE, format = "pandoc")
# you can run the code below to download the data (remember your api keys!)
# or load it pre-processed from here:
load(file = path(data_path, "nyc_cb_poly.RData"))
# Download OpenStreetMap data for the NYC metro area from Interline map extracts
download.file(url = paste0("https://app.interline.io/osm_extracts/download_latest?string_id=new-york_new-york&data_format=pbf&api_token=", interline_token),
destfile = file.path(r5_path, "osm.pbf"), mode = "wb")
nyc_subway_gtfs <- read_gtfs(path = file.path(r5_path, "nyct_subway.zip"))
summary(nyc_subway_gtfs)
# 1. Generalize calls to input simple features
# origins
origins_i <-  nyc_cb_poly
origins_id_field <- "Block_GEOID"
# destinations
destinations_j <-  nyc_cb_poly
destinations_id_field <- "Block_GEOID"
opportunities_j_field <- "total_emp"
# select your impedance functions
selected_f <- c("POW2_0", "EXP0_15", "MGAUS180", "CUML40", "CUMR40") # pick one or more impedance functions
# 2. R5 Travel Time Matrix Options. See https://rdrr.io/cran/r5r/man/travel_time_matrix.html for more detail
# R5 allows for multiple combinations of transport modes. The options include:
## Transit modes
# TRAM, SUBWAY, RAIL, BUS, FERRY, CABLE_CAR, GONDOLA, FUNICULAR.
# The option 'TRANSIT' automatically considers all public transport modes available.
## Non transit modes
# WALK, BICYCLE, CAR, BICYCLE_RENT, CAR_PARK
# define your travel modes
mode <- c("WALK", "TRANSIT")
# egress mode
#mode_egress = "WALK" # Transport mode used after egress from public transport; it can be either 'WALK', 'BICYCLE', or 'CAR'. Defaults to "WALK"
# walk speed
#walk_speed = 3.6 #Average walk speed in km/h. Defaults to 3.6 km/h
# bike speed
#bike_speed = 12 # Average cycling speed in km/h. Defaults to 12 km/h
# max rides
#max_rides = 3 # The max number of public transport rides allowed in the same trip. Defaults to 3
# level of traffic stress (cycling)
#max_lts = 2 # The maximum level of traffic stress that cyclists will tolerate. A value of 1 means cyclists will only travel through the quietest streets, while a value of 4 indicates cyclists can travel through any road; defaults to 2
# define trip start datetime
departure_datetime <- as.POSIXct("2021-03-22 08:00:00",  # must be within calendar range of gtfs
format = "%Y-%m-%d %H:%M:%S",
tz = "America/New_York") # see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for list of time zone codes
# maximum walk distance (in metres)
max_walk_dist = 4000
# max trip duration (minutes)
max_trip_duration = 120
# processing batch size - how many origin rows to process at one time
chunksize = 500 # how many origins to consider at one time; set to nrow(origins_sf) if you don't want to use
# multithreading
n_threads = Inf # The number of threads to use in parallel computing; defaults to use all available threads (Inf)
r5r_core <- setup_r5(data_path = r5_path, verbose = FALSE)
# assemble all impedance functions into a list
impedance_f <- c(POW, NEG_EXP, MGAUS, CUMR, CUML)
# ORIGINS
# create input sf object and change to crs 4326 for origins
origins_i_sf <- origins_i %>%
select(all_of(origins_id_field)) %>%
rename(id = all_of(origins_id_field))
origins_i <- origins_i_sf %>%
st_centroid() %>% # to centroids
st_transform(crs = 4326) %>% # transform to lat-longs
mutate(batch_id = ceiling(row_number()/chunksize))
# DESTINATIONS
# create input sf object and change to crs 4326 for destinations
destinations_j <- destinations_j %>%
select(all_of(c(destinations_id_field, opportunities_j_field))) %>%
rename(id = all_of(destinations_id_field), o_j = all_of(opportunities_j_field)) %>%
filter(o_j > 0) %>%
st_centroid() %>% # to centroids
st_transform(crs = 4326) # transform to lat-longs
opportunities_j <- destinations_j %>%
st_drop_geometry() %>%
select(id, o_j) %>%
rename(toId = id)
ttm <- open_dataset(path(ttm_path))
accessibility <- ttm %>%
map_batches(function(batch) {
batch %>%
as.data.frame() %>%
# join opportunities
left_join(opportunities_j, by = "toId") %>%
# mutate across the selected functions
mutate(across(travel_time, .fns= impedance_f[selected_f], .names = "{fn}")) %>%
# multiply weights by opportunities
mutate(across(all_of(selected_f), .fns = function(f) f*.$o_j)) %>%
# summarize results
group_by(fromId) %>%
summarize(across(all_of(selected_f), sum))
})
# join results to input_sf object
input_sf_accessibility <- left_join(origins_i_sf, accessibility, by=c("id" = "fromId"))
# iterate through selected functions to create maps
accessibility_maps <- list()
for (i in selected_f){
map <- tm_shape(input_sf_accessibility) +
tm_fill(col = i,
title = i,
style = "cont",
palette = "viridis") +
tm_layout(frame = FALSE,
bg.color = "grey85",
legend.position = c("left", "top"),
legend.text.color = "white",
legend.title.color = "white")
accessibility_maps[[i]] <- map}
names(accessibility_maps) <- selected_f
# plot the maps
tmap_arrange(accessibility_maps)
# create dataframe of variables for correlation analysis
correlations <- input_sf_accessibility %>% select(all_of(selected_f)) %>% st_drop_geometry() %>% drop_na() %>% cor(.)
corrplot(correlations,
method = "color", # corrplot method
type = "upper", # upper triangle matrix
addCoef.col = "white", # correlation text colour
number.cex = 0.8, # correlation text size
tl.col = "black", # text label colour
tl.srt = 45, # text label angle
tl.cex = 0.9, # text label size
cl.lim = c(min(correlations), 1), # colour label limits
#diag = FALSE, # turn off diagonal
is.corr=FALSE, # because all coefficients are positive
col = viridis::viridis(100)) # custom colour scheme based on viridis hex values
# set up batching
num_chunks = origins_i %>% st_drop_geometry() %>% summarize(num_chunks = max(batch_id)) %>% pull(num_chunks)
# compute travel time matrix
start.time <- Sys.time()
pb <- txtProgressBar(0, num_chunks, style = 3)
for (i in 1:num_chunks){
origins_i_chunk <- origins_i %>% filter(batch_id == i)
ttm_chunk <- travel_time_matrix(
r5r_core = r5r_core,
origins = origins_i_chunk,
destinations = destinations_j,
mode = mode,
departure_datetime = departure_datetime,
max_walk_dist = max_walk_dist,
max_trip_duration = max_trip_duration,
verbose = FALSE,
progress = FALSE) %>%
mutate(batch_id = i)
# export output as parquet
write_dataset(ttm_chunk, path = ttm_path, partitioning = "batch_id")
setTxtProgressBar(pb, i)}
end.time <- Sys.time()
print(paste0("OD matrix calculation took ", round(difftime(end.time, start.time, units = "mins"), digits = 2), " minutes..."))
ttm <- open_dataset(path(ttm_path))
accessibility <- ttm %>%
map_batches(function(batch) {
batch %>%
as.data.frame() %>%
# join opportunities
left_join(opportunities_j, by = "toId") %>%
# mutate across the selected functions
mutate(across(travel_time, .fns= impedance_f[selected_f], .names = "{fn}")) %>%
# multiply weights by opportunities
mutate(across(all_of(selected_f), .fns = function(f) f*.$o_j)) %>%
# summarize results
group_by(fromId) %>%
summarize(across(all_of(selected_f), sum))
})
View(accessibility)
# join results to input_sf object
input_sf_accessibility <- left_join(origins_i_sf, accessibility, by=c("id" = "fromId"))
# iterate through selected functions to create maps
accessibility_maps <- list()
for (i in selected_f){
map <- tm_shape(input_sf_accessibility) +
tm_fill(col = i,
title = i,
style = "cont",
palette = "viridis") +
tm_layout(frame = FALSE,
bg.color = "grey85",
legend.position = c("left", "top"),
legend.text.color = "white",
legend.title.color = "white")
accessibility_maps[[i]] <- map}
names(accessibility_maps) <- selected_f
# plot the maps
tmap_arrange(accessibility_maps)
# create dataframe of variables for correlation analysis
correlations <- input_sf_accessibility %>% select(all_of(selected_f)) %>% st_drop_geometry() %>% drop_na() %>% cor(.)
corrplot(correlations,
method = "color", # corrplot method
type = "upper", # upper triangle matrix
addCoef.col = "white", # correlation text colour
number.cex = 0.8, # correlation text size
tl.col = "black", # text label colour
tl.srt = 45, # text label angle
tl.cex = 0.9, # text label size
cl.lim = c(min(correlations), 1), # colour label limits
#diag = FALSE, # turn off diagonal
is.corr=FALSE, # because all coefficients are positive
col = viridis::viridis(100)) # custom colour scheme based on viridis hex values
